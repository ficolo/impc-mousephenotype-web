{"ast":null,"code":"import React, { useContext, useEffect, useMemo } from 'react';\nimport { stack as d3stack } from 'd3-shape';\nimport stackOffset from '@visx/shape/lib/util/stackOffset';\nimport stackOrder from '@visx/shape/lib/util/stackOrder';\nimport { extent } from 'd3-array';\nimport DataContext from '../context/DataContext';\nimport getBarStackRegistryData from '../utils/getBarStackRegistryData';\nimport combineBarStackData from '../utils/combineBarStackData';\nimport isChildWithProps from '../typeguards/isChildWithProps';\nexport default function useStackedData(_ref) {\n  var children = _ref.children,\n      order = _ref.order,\n      offset = _ref.offset;\n\n  var _ref2 = useContext(DataContext),\n      horizontal = _ref2.horizontal,\n      registerData = _ref2.registerData,\n      unregisterData = _ref2.unregisterData; // find series children\n  // @TODO: memoization doesn't work well if at all for this\n\n\n  var seriesChildren = useMemo(function () {\n    return React.Children.toArray(children).filter(function (child) {\n      return isChildWithProps(child);\n    });\n  }, [children]); // extract data keys from child series\n\n  var dataKeys = useMemo(function () {\n    return seriesChildren.filter(function (child) {\n      return child.props.dataKey;\n    }).map(function (child) {\n      return child.props.dataKey;\n    });\n  }, [seriesChildren]); // group all child data by stack value { [x | y]: { [dataKey]: value } }\n  // this format is needed by d3Stack\n\n  var combinedData = useMemo(function () {\n    return combineBarStackData(seriesChildren, horizontal);\n  }, [horizontal, seriesChildren]); // stack data\n\n  var stackedData = useMemo(function () {\n    // automatically set offset to diverging if it's undefined and negative values are present\n    var hasSomeNegativeValues = offset ? null : combinedData.some(function (d) {\n      return d.negativeSum < 0;\n    });\n    var stack = d3stack();\n    stack.keys(dataKeys);\n    if (order) stack.order(stackOrder(order));\n    if (offset || hasSomeNegativeValues) stack.offset(stackOffset(offset || 'diverging'));\n    return stack(combinedData);\n  }, [combinedData, dataKeys, order, offset]); // update the domain to account for the (directional) stacked value\n\n  var comprehensiveDomain = useMemo(function () {\n    return extent(stackedData.reduce(function (allDatum, stack) {\n      stack.forEach(function (_ref3) {\n        var min = _ref3[0],\n            max = _ref3[1];\n        allDatum.push(min);\n        allDatum.push(max);\n      });\n      return allDatum;\n    }, []));\n  }, [stackedData]); // register all child data using the stack-transformed values\n\n  useEffect(function () {\n    var dataToRegister = getBarStackRegistryData(stackedData, comprehensiveDomain, horizontal);\n    registerData(dataToRegister); // unregister data on unmount\n\n    return function () {\n      return unregisterData(dataKeys);\n    };\n  }, [dataKeys, comprehensiveDomain, horizontal, stackedData, registerData, unregisterData, seriesChildren]);\n  return {\n    seriesChildren: seriesChildren,\n    dataKeys: dataKeys,\n    stackedData: stackedData\n  };\n}","map":{"version":3,"sources":["/Users/federico/git/test/impc-mousephenotype-web/node_modules/@visx/xychart/esm/hooks/useStackedData.js"],"names":["React","useContext","useEffect","useMemo","stack","d3stack","stackOffset","stackOrder","extent","DataContext","getBarStackRegistryData","combineBarStackData","isChildWithProps","useStackedData","_ref","children","order","offset","_ref2","horizontal","registerData","unregisterData","seriesChildren","Children","toArray","filter","child","dataKeys","props","dataKey","map","combinedData","stackedData","hasSomeNegativeValues","some","d","negativeSum","keys","comprehensiveDomain","reduce","allDatum","forEach","_ref3","min","max","push","dataToRegister"],"mappings":"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","sourcesContent":["import React, { useContext, useEffect, useMemo } from 'react';\nimport { stack as d3stack } from 'd3-shape';\nimport stackOffset from '@visx/shape/lib/util/stackOffset';\nimport stackOrder from '@visx/shape/lib/util/stackOrder';\nimport { extent } from 'd3-array';\nimport DataContext from '../context/DataContext';\nimport getBarStackRegistryData from '../utils/getBarStackRegistryData';\nimport combineBarStackData from '../utils/combineBarStackData';\nimport isChildWithProps from '../typeguards/isChildWithProps';\nexport default function useStackedData(_ref) {\n  var children = _ref.children,\n      order = _ref.order,\n      offset = _ref.offset;\n\n  var _ref2 = useContext(DataContext),\n      horizontal = _ref2.horizontal,\n      registerData = _ref2.registerData,\n      unregisterData = _ref2.unregisterData; // find series children\n  // @TODO: memoization doesn't work well if at all for this\n\n\n  var seriesChildren = useMemo(function () {\n    return React.Children.toArray(children).filter(function (child) {\n      return isChildWithProps(child);\n    });\n  }, [children]); // extract data keys from child series\n\n  var dataKeys = useMemo(function () {\n    return seriesChildren.filter(function (child) {\n      return child.props.dataKey;\n    }).map(function (child) {\n      return child.props.dataKey;\n    });\n  }, [seriesChildren]); // group all child data by stack value { [x | y]: { [dataKey]: value } }\n  // this format is needed by d3Stack\n\n  var combinedData = useMemo(function () {\n    return combineBarStackData(seriesChildren, horizontal);\n  }, [horizontal, seriesChildren]); // stack data\n\n  var stackedData = useMemo(function () {\n    // automatically set offset to diverging if it's undefined and negative values are present\n    var hasSomeNegativeValues = offset ? null : combinedData.some(function (d) {\n      return d.negativeSum < 0;\n    });\n    var stack = d3stack();\n    stack.keys(dataKeys);\n    if (order) stack.order(stackOrder(order));\n    if (offset || hasSomeNegativeValues) stack.offset(stackOffset(offset || 'diverging'));\n    return stack(combinedData);\n  }, [combinedData, dataKeys, order, offset]); // update the domain to account for the (directional) stacked value\n\n  var comprehensiveDomain = useMemo(function () {\n    return extent(stackedData.reduce(function (allDatum, stack) {\n      stack.forEach(function (_ref3) {\n        var min = _ref3[0],\n            max = _ref3[1];\n        allDatum.push(min);\n        allDatum.push(max);\n      });\n      return allDatum;\n    }, []));\n  }, [stackedData]); // register all child data using the stack-transformed values\n\n  useEffect(function () {\n    var dataToRegister = getBarStackRegistryData(stackedData, comprehensiveDomain, horizontal);\n    registerData(dataToRegister); // unregister data on unmount\n\n    return function () {\n      return unregisterData(dataKeys);\n    };\n  }, [dataKeys, comprehensiveDomain, horizontal, stackedData, registerData, unregisterData, seriesChildren]);\n  return {\n    seriesChildren: seriesChildren,\n    dataKeys: dataKeys,\n    stackedData: stackedData\n  };\n}"]},"metadata":{},"sourceType":"module"}